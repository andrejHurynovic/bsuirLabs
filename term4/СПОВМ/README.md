# СПОВМ
### Методичка – В.А. Супонев, А.А. Уваров, В.А. Прытков
### [Лабараторная работа № 1](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%201.%20Process)
Необходимо разработать консольное приложение, в котором базовый процесс порождает дочерний. Следует предусмотреть для каждого процесса свою область вывода, в которую выводится текущее системное время. Под Linux использовать библиотеку ncurses.
### [Лабараторная работа № 2](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%202.%20Synchronization)
Необходимо разработать многопроцессное приложение. Исходный процесс является управляющим, принимает поток ввода с клавиатуры и контролирует дочерние процессы. По нажатии клавиши ‘+’ добавляется новый процесс, ‘-’ - удаляется последний добавленный, ‘q’ - программа завершается. Каждый дочерний процесс посимвольно выводит на экран в вечном цикле свою уникальную строку. При этом операция вывода строки должна быть атомарной, т.е. процесс вывода должен быть синхронизирован таким образом, чтобы строки на экране не перемешивались. В качестве метода синхронизации следует использовать сигналы/события.
### [Лабараторная работа № 3](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%203.%20Process%20interaction)
Необходимо создать два процесса: клиентский и серверный. Серверный процесс ждет ввода пользователем текстовой строки и по нажатии клавиши Enter инициируются следующие действия:
- клиентский процесс ожидает уведомления о том, что серверный процесс готов начать передачу данных (синхронизация);
- серверный процесс передает полученную от пользователя строку клиентскому процессу, используя либо каналы, либо сегменты разделяемой памяти / файловые проекции;
- клиентский процесс принимает строку и выводит ее на экран;
- серверный процесс ожидает уведомления от клиентского процесса об успешном получении строки;
- серверный процесс вновь ожидает ввода строки пользователем и т.д.

В данной работе продолжается освоение синхронизации процессов. Уведомление процессов должно производиться посредством семафоров. Реализация механизма непосредственной передачи данных остается на выбор студента, однако в теории освоены должны быть все варианты.
### [Лабараторная работа № 4](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%204.%20Threads)
Задание аналогично заданию 2.3 из лабораторной работы № 2, но с реализацией с помощью потоков.
### [Лабараторная работа № 5](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%205.%20Libraries)
В каталоге имеется набор текстовых файлов. Необходимо разработать приложение из двух потоков, которые работают по следующей схеме:
1) первый поток (поток-читатель) асинхронным образом считывает содержимое одного файла;
2) поток-читатель уведомляет второй поток (поток-писатель) о том, что содержимое файла прочитано и может быть передано писателю;
3) поток-писатель получает от потока-читателя содержимое файла и асинхронным образом записывает полученную строку в конец выходного файла;
4) поток-читатель получает уведомление от потока-писателя о том, что строка записана в выходной файл и можно приступать к чтению следующего файла;
5) процедура повторяется с п.1, пока не закончится список файлов.

В результате должна быть произведена конкатенация (объединение) входных текстовых файлов в один результирующий.
Функции чтения - записи должны быть выделены в динамическую библиотеку, подключены на этапе выполнения программы и выгружены после отработки основного цикла.
### [Лабараторная работа № 6](https://github.com/andrejHurynovic/bsuirLabs/tree/main/term4/СПОВМ/Labworks/Labwork%206.%20Memory%20manager) (Вариант № 3)
Разработать собственный менеджер памяти, реализующий аналоги функций mallос() и free(). Архитектура менеджера и детали реализации остаются на усмотрение студента. Предусмотреть дополнительную функциональность в од­ ном из следующих вариантов:
1) динамическое изменение размеров выделенной области (reallocQ);
2) автоматическая сборка мусора; 
3) **дефрагментация;**
4) механизм свопинга при превышении максимально доступной памяти.
